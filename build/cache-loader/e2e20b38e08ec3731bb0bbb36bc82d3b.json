{"remainingRequest":"H:\\projects\\limsy-application\\node_modules\\thread-loader\\dist\\cjs.js??ref--4-2!H:\\projects\\limsy-application\\node_modules\\ts-loader\\index.js??ref--4-3!H:\\projects\\limsy-application\\node_modules\\tslint-loader\\index.js!H:\\projects\\limsy-application\\src\\main\\webapp\\app\\shared\\auth\\private-route.tsx","dependencies":[{"path":"H:\\projects\\limsy-application\\src\\main\\webapp\\app\\shared\\auth\\private-route.tsx","mtime":1549223105124},{"path":"H:\\projects\\limsy-application\\node_modules\\react-hot-loader\\webpack.js","mtime":1549223610051},{"path":"H:\\projects\\limsy-application\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1549223563882},{"path":"H:\\projects\\limsy-application\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1549223563895},{"path":"H:\\projects\\limsy-application\\node_modules\\ts-loader\\index.js","mtime":1549223611188},{"path":"H:\\projects\\limsy-application\\node_modules\\tslint-loader\\index.js","mtime":1549223603361}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Route, Redirect } from 'react-router-dom';\r\nimport ErrorBoundary from 'app/shared/error/error-boundary';\r\nexport var PrivateRouteComponent = function (_a) {\r\n    var Component = _a.component, isAuthenticated = _a.isAuthenticated, sessionHasBeenFetched = _a.sessionHasBeenFetched, isAuthorized = _a.isAuthorized, _b = _a.hasAnyAuthorities, hasAnyAuthorities = _b === void 0 ? [] : _b, rest = tslib_1.__rest(_a, [\"component\", \"isAuthenticated\", \"sessionHasBeenFetched\", \"isAuthorized\", \"hasAnyAuthorities\"]);\r\n    var checkAuthorities = function (props) {\r\n        return isAuthorized ? (React.createElement(ErrorBoundary, null,\r\n            React.createElement(Component, tslib_1.__assign({}, props)))) : (React.createElement(\"div\", { className: \"insufficient-authority\" },\r\n            React.createElement(\"div\", { className: \"alert alert-danger\" }, \"You are not authorized to access this page.\")));\r\n    };\r\n    var renderRedirect = function (props) {\r\n        if (!sessionHasBeenFetched) {\r\n            return React.createElement(\"div\", null);\r\n        }\r\n        else {\r\n            return isAuthenticated ? (checkAuthorities(props)) : (React.createElement(Redirect, { to: {\r\n                    pathname: '/login',\r\n                    search: props.location.search,\r\n                    state: { from: props.location }\r\n                } }));\r\n        }\r\n    };\r\n    if (!Component)\r\n        throw new Error(\"A component needs to be specified for private route for path \" + rest.path);\r\n    return React.createElement(Route, tslib_1.__assign({}, rest, { render: renderRedirect }));\r\n};\r\nexport var hasAnyAuthority = function (authorities, hasAnyAuthorities) {\r\n    if (authorities && authorities.length !== 0) {\r\n        if (hasAnyAuthorities.length === 0) {\r\n            return true;\r\n        }\r\n        return hasAnyAuthorities.some(function (auth) { return authorities.includes(auth); });\r\n    }\r\n    return false;\r\n};\r\nvar mapStateToProps = function (_a, _b) {\r\n    var _c = _a.authentication, isAuthenticated = _c.isAuthenticated, account = _c.account, sessionHasBeenFetched = _c.sessionHasBeenFetched;\r\n    var _d = _b.hasAnyAuthorities, hasAnyAuthorities = _d === void 0 ? [] : _d;\r\n    return ({\r\n        isAuthenticated: isAuthenticated,\r\n        isAuthorized: hasAnyAuthority(account.authorities, hasAnyAuthorities),\r\n        sessionHasBeenFetched: sessionHasBeenFetched\r\n    });\r\n};\r\n/**\r\n * A route wrapped in an authentication check so that routing happens only when you are authenticated.\r\n * Accepts same props as React router Route.\r\n * The route also checks for authorization if hasAnyAuthorities is specified.\r\n */\r\nexport var PrivateRoute = connect(mapStateToProps, null, null, { pure: false })(PrivateRouteComponent);\r\nexport default PrivateRoute;\r\n",{"version":3,"file":"H:\\projects\\limsy-application\\src\\main\\webapp\\app\\shared\\auth\\private-route.tsx","sourceRoot":"","sources":["H:\\projects\\limsy-application\\node_modules\\tslint-loader\\index.js!H:\\projects\\limsy-application\\src\\main\\webapp\\app\\shared\\auth\\private-route.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACtC,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAc,MAAM,kBAAkB,CAAC;AAG/D,OAAO,aAAa,MAAM,iCAAiC,CAAC;AAQ5D,MAAM,CAAC,IAAM,qBAAqB,GAAG,UAAC,EAOjB;IANnB,IAAA,wBAAoB,EACpB,oCAAe,EACf,gDAAqB,EACrB,8BAAY,EACZ,yBAAsB,EAAtB,2CAAsB,EACtB,yHAAO;IAEP,IAAM,gBAAgB,GAAG,UAAA,KAAK;QAC5B,OAAA,YAAY,CAAC,CAAC,CAAC,CACb,oBAAC,aAAa;YACZ,oBAAC,SAAS,uBAAK,KAAK,EAAI,CACV,CACjB,CAAC,CAAC,CAAC,CACF,6BAAK,SAAS,EAAC,wBAAwB;YACrC,6BAAK,SAAS,EAAC,oBAAoB,kDAAkD,CACjF,CACP;IARD,CAQC,CAAC;IAEJ,IAAM,cAAc,GAAG,UAAA,KAAK;QAC1B,IAAI,CAAC,qBAAqB,EAAE;YAC1B,OAAO,gCAAO,CAAC;SAChB;aAAM;YACL,OAAO,eAAe,CAAC,CAAC,CAAC,CACvB,gBAAgB,CAAC,KAAK,CAAC,CACxB,CAAC,CAAC,CAAC,CACF,oBAAC,QAAQ,IACP,EAAE,EAAE;oBACF,QAAQ,EAAE,QAAQ;oBAClB,MAAM,EAAE,KAAK,CAAC,QAAQ,CAAC,MAAM;oBAC7B,KAAK,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,QAAQ,EAAE;iBAChC,GACD,CACH,CAAC;SACH;IACH,CAAC,CAAC;IAEF,IAAI,CAAC,SAAS;QAAE,MAAM,IAAI,KAAK,CAAC,kEAAiE,IAAY,CAAC,IAAM,CAAC,CAAC;IAEtH,OAAO,oBAAC,KAAK,uBAAK,IAAI,IAAE,MAAM,EAAE,cAAc,IAAI,CAAC;AACrD,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,eAAe,GAAG,UAAC,WAAqB,EAAE,iBAA2B;IAChF,IAAI,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3C,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC;SACb;QACD,OAAO,iBAAiB,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAA1B,CAA0B,CAAC,CAAC;KACnE;IACD,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,IAAM,eAAe,GAAG,UACtB,EAAmF,EACnF,EAAqC;QADnC,sBAAmE,EAAjD,oCAAe,EAAE,oBAAO,EAAE,gDAAqB;QACjE,yBAAsB,EAAtB,2CAAsB;IACrB,OAAA,CAAC;QACJ,eAAe,iBAAA;QACf,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,WAAW,EAAE,iBAAiB,CAAC;QACrE,qBAAqB,uBAAA;KACtB,CAAC;AAJG,CAIH,CAAC;AAIH;;;;GAIG;AACH,MAAM,CAAC,IAAM,YAAY,GAAG,OAAO,CACjC,eAAe,EACf,IAAI,EACJ,IAAI,EACJ,EAAE,IAAI,EAAE,KAAK,EAAE,CAChB,CAAC,qBAAqB,CAAC,CAAC;AAEzB,eAAe,YAAY,CAAC","sourcesContent":["import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Route, Redirect, RouteProps } from 'react-router-dom';\r\n\r\nimport { IRootState } from 'app/shared/reducers';\r\nimport ErrorBoundary from 'app/shared/error/error-boundary';\r\n\r\ninterface IOwnProps extends RouteProps {\r\n  hasAnyAuthorities?: string[];\r\n}\r\n\r\nexport interface IPrivateRouteProps extends IOwnProps, StateProps {}\r\n\r\nexport const PrivateRouteComponent = ({\r\n  component: Component,\r\n  isAuthenticated,\r\n  sessionHasBeenFetched,\r\n  isAuthorized,\r\n  hasAnyAuthorities = [],\r\n  ...rest\r\n}: IPrivateRouteProps) => {\r\n  const checkAuthorities = props =>\r\n    isAuthorized ? (\r\n      <ErrorBoundary>\r\n        <Component {...props} />\r\n      </ErrorBoundary>\r\n    ) : (\r\n      <div className=\"insufficient-authority\">\r\n        <div className=\"alert alert-danger\">You are not authorized to access this page.</div>\r\n      </div>\r\n    );\r\n\r\n  const renderRedirect = props => {\r\n    if (!sessionHasBeenFetched) {\r\n      return <div />;\r\n    } else {\r\n      return isAuthenticated ? (\r\n        checkAuthorities(props)\r\n      ) : (\r\n        <Redirect\r\n          to={{\r\n            pathname: '/login',\r\n            search: props.location.search,\r\n            state: { from: props.location }\r\n          }}\r\n        />\r\n      );\r\n    }\r\n  };\r\n\r\n  if (!Component) throw new Error(`A component needs to be specified for private route for path ${(rest as any).path}`);\r\n\r\n  return <Route {...rest} render={renderRedirect} />;\r\n};\r\n\r\nexport const hasAnyAuthority = (authorities: string[], hasAnyAuthorities: string[]) => {\r\n  if (authorities && authorities.length !== 0) {\r\n    if (hasAnyAuthorities.length === 0) {\r\n      return true;\r\n    }\r\n    return hasAnyAuthorities.some(auth => authorities.includes(auth));\r\n  }\r\n  return false;\r\n};\r\n\r\nconst mapStateToProps = (\r\n  { authentication: { isAuthenticated, account, sessionHasBeenFetched } }: IRootState,\r\n  { hasAnyAuthorities = [] }: IOwnProps\r\n) => ({\r\n  isAuthenticated,\r\n  isAuthorized: hasAnyAuthority(account.authorities, hasAnyAuthorities),\r\n  sessionHasBeenFetched\r\n});\r\n\r\ntype StateProps = ReturnType<typeof mapStateToProps>;\r\n\r\n/**\r\n * A route wrapped in an authentication check so that routing happens only when you are authenticated.\r\n * Accepts same props as React router Route.\r\n * The route also checks for authorization if hasAnyAuthorities is specified.\r\n */\r\nexport const PrivateRoute = connect<StateProps, undefined, IOwnProps>(\r\n  mapStateToProps,\r\n  null,\r\n  null,\r\n  { pure: false }\r\n)(PrivateRouteComponent);\r\n\r\nexport default PrivateRoute;\r\n"]}]}